## AT&T汇编

* 关键词必须使用**小写字母**，例如：mov $0x10, %ax；
* 赋值方向：第一个是源操作数，第二个是目标操作数，赋值方向从左到右；
* 大部分指令访问数据时需要指明操作数位宽：
  ```assembly
  # b 表示一个字节
  movb $12, %al
  
  # w 表示一个字（两字节）
  movw $1212, %ax
  
  # l 表示两个字（四字节）
  movl $12121212, %eax
  
  # q 表示四个字（八字节）
  movq %rax, %rbx
  
  # 跳转指令可以添加后缀表示跳转方向，f 向前跳转（forward），b 向后跳转（back）
  jmp 1f
  1:
  ```
* 远程跳转指令必须使用前缀 `l`加以修饰：
  ```assembly
  lcall $section:$offset
  ljmp $section:$offset
  lret
  ```
* 寄存器前面添加指令前缀 **%**，立即数前面添加前缀 **$**。例如：mov $12, %cx；

  * 标识符变量，添加与不添加前缀的含义，例如：

    ```assembly
    # 将 0x505a 赋值给寄存器 eax
    values: .long 0x505a
    movl values, %eax
    
    # 如果添加标识符前缀，则引用该变量地址
    movl $values, %ebx # 将 values 的地址赋值给 ebx
    ```
* 使用 `()` 表示间接寻址，格式 `section:displacement(base, index, scale)`



## C 嵌入汇编

```c
#define nop() __asm__ __volatile__("nop \n\t")
```

* `__asm__`：该行代码是内嵌汇编表达式，是关键字 asm 的宏定义（`#define __asm__ asm`）；
* `__volatile__`：告诉编译器此行代码不能被编译器优化，编译时保持代码原状；

### 内嵌汇编表达式

格式：`指令部分: 输出部分: 输入部分: 损坏部分`

* `指令部分`：
  * 多条汇编时，可将其放在一个双引号中，指令间用 `;`或`\n`分割；也可放在多个双引号中；
  * 对寄存器引用时，再在前面加一个 `%`，例如：`movl $0x10, %%eax`；
* `输出部分`：记录指令的部分输出，格式为 `"输出操作约束"(输出表达式), "输出操作约束"(输出表达式),...`
  * 输出表达式：负责保存指令部分的执行结果，通常情况是一个变量；
  * 输出操作约束：**必须使用 = 或 + 进行修饰**，= 纯粹的输出操作，+ 用于输出操作，又用于输入操作；
  * **&修饰符**：只能位于 = 或 + 之后，告诉编译器不得为任务输入操作表达式分配该寄存器（只有在输入约束中使用 q/r/g 等模糊约束时才有意义）；
  * =/+ 只能用于输出部分，不能出现在输入部分，且是可读写的；
* `输入部分`：记录指令的输入部分，格式为 `"输入操作约束"(输入表达式), "输入操作约束"(输入表达式),...`
  * 输入部分是只读的；
* `损坏部分`：指令执行过程中，将被修改的寄存器、内存空间或标志寄存器，并且这些修改部分**并未在输出部分和输入部分出现过**（输入输出部分会进行数据保存和恢复），格式 `"损坏描述", "损坏描述",...`
  * 寄存器修改通知：发生在寄存器出现在指令中，但又不是输入/输出操作表达式指定的寄存器，更不是编译器为 r 或 g 约束选择的寄存器。编译器会做好数据保存和恢复工作；
  * 内存修改通知：如果损坏部分已经使用 memory 对内存加以约束，那么编译器会保证在执行汇编表达式后重新向寄存器中装载已引用过的内存空间，而非使用寄存器中的副本，以防止内存与副本中的数据不一致。
  * 标志寄存器修改通知：

### 操作约束

#### 寄存器约束

```c
__asm__ __volatile__("movl %0, %%cr0"::"eax"(cr0));
__asm__ __volatile__("movl %0, %%cr0"::"a"(cr0));
```

| 缩写 | 描 述                               |
| ---- | ----------------------------------- |
| r    | 任何输入/输出型的寄存器             |
| q    | 从 eax/ebx/ecx/edx 中指派一个寄存器 |
| g    | 寄存器或内存空间                    |
| m    | 内存空间                            |
| a    | 使用 rax/eax/ax/al 寄存器           |
| b    | 使用 rbx/ebx/bx/bl 寄存器           |
| c    | 使用 rcx/ecx/cx/cl 寄存器           |
| d    | 使用 rdx/edx/dx/dl 寄存器           |
| D    | 使用 rdi/edi/di 寄存器              |
| S    | 使用 rsi/esi/si 寄存器              |
| f    | 选用浮点寄存器                      |
| i    | 一个整数类型的立即数                |
| F    | 一个浮点类型的立即数                |

#### 内存约束

限定了表达式的载体是一个内存空间，使用约束名 m 表示：

```c
__asm__ __volatile__("sgdt %0":"=m"(__gdt_addr)::);
__asm__ __volatile__("lgdt %0"::"m"(__gdt_addr));
```

#### 立即数约束

**只能用于输入部分**，不借助任何寄存器或内存，可以使用立即数约束：

```c
__asm__ __volatile__("movl %0, %%ebx"::"i"(50));
```





